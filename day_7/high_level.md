# Cracking the Code: How to Build & Solve a Caesar Cipher with Ruby

Often thought of as a simple encoding concept today, Caesar Ciphers work by having the cipher take in a string, rotate letter elements of this string by a certain number of positions, which exist within the alphabet, and then return a new string with "scrambled" letters and a new *secret message*. Having this in mind, let's walk through how we could implement a program to solve a Caesar Cipher:


Let's begin implementation by creating a **class** for a Caesar Cipher called `class CaesarCipher`. We then **instantiate** the object `cipher`, which takes in an argument to the `.new` method. This argument is in reference to the position within a given array of letters `cipher` will rotate.

Inside of the class, there are two **attributes** we will want to keep track of: `alphabet` for the letters of the alphabet that we will use and `position`, which will change as we shift or rotate `alphabet` a given number of positions.

After creating `class CaesarCipher` we can include the **accessor methods** `attr_accessor` for `position` and `attr_reader` for `alphabet`. `attr_accessor` is a really handy, built-in method to `Ruby` that condenses our getter and setter methods we would normally need to be able to access the state of our instance variables, and `attr_reader` allows us to read the state of the instance variable without having access to update it. In other words, because a class does not expose its instance variables to the outside world, accessor methods, essentially, "open the window" and allow us to read values given to the instance variable, update/write new information to the instance variable or both.

After this, we can create **instance variables** for `position` and `alphabet` inside of the `def initialize` method and make sure to prepend `@` in front of the variables to show that they are instances of `class CaeserCipher`. Now every time we create a new object of the class, the `initialize method` will be triggered and give access to these two attributes.

Okay, and now to get into the *meat and potatoes* of the program! We have these two attributes, what do we do next? Let's *do something* to these attributes by creating **methods**. Methods within a class allow you to execute a piece of code many times over throughout the program and also make changes in one place that will affect many places within the program as it evolves. For `class CaesarCipher`, we can create a method that is called upon the `cipher` instance and takes in a message from the user passed in as a string. The result from this method should return a new, encrypted message. Let's call the method `def encrypt(string)`.

Within the method `def encrypt(string)`, we will take the string passed in by the user, convert it to an array using our `alphabet` instance method(given to us by the attr_reader method), and then call the method `rotate` on the original `alphabet` array. Rotate is another handy `Ruby` method for arrays that rotates an array given the number passed in, and the element that exists at that given number or count which was passed in now becomes the first element in the newly returned array. So with this information, we can pass in `position` to the `.rotate()` method and inquire input from the user to give a number in which the original `alphabet` array will be rotated.

After we rotate the original `alphabet` array and get a `new_array`, we then pass this value into the `.zip` method as an argument, which is called upon our original `alphabet` array. Imagine `.zip` like you would a zipper on your favorite hoodie. On each side of the zipper you have a separate set teeth. When you *zip* up your hoodie, now both sets of these teeth come together as one. Behind the scenes, `.zip` is performing the same way; it takes the argument that is passed in (converts the argument to an array if it's not already) and merges together the elements of the array that `.zip` is invoked on **and** the corresponding elements from the argument. So, we are calling `.zip` on the array `alphabet` and passing this newly rotated array as an argument to zip to match the elements from the rotated array to the elements of our original `alphabet` instance. What is returned is a new array of subsequent arrays that have mapped corresponding values for each element within each array.

Finally, we take the value that is returned from `alphabet.zip()` and pass that into a `Hash` so that we can create `key-value pairs` of the mapped elements from our original `alphabet` array to the elements at the corresponding indices of the newly rotated array. For example, if we call `alphabet.rotate(2)`, `['a', 'b', 'c', 'd']` would become ['c', 'd', 'a', 'b']. We then *zip* together these two arrays so they would look like `[['a', 'c'], ['b', 'd'], ['c', 'a'], ['d', 'b']]`. From here, create a `Hash` and pass in this array of arrays as our argument, which results in `['a' =>'c', 'b' => 'd', 'c' => 'a', 'd' => 'b']`. We then store all of this logic and information inside a variable so that we can easily access it throughout the program.

Now that we have one piece of the logic puzzle, we have to get the rest of it so we can encrypt the user's message. To do so, we will have to iterate over the string passed in by the user, and for each individual letter element, use a looping function to map or reference the character from the user's string to its corresponding value within the hash variable we just created. Once we find out that value, we then store it within a new *encrypted letter* variable, and concatenate it within the new string. As the program loops through each character, it will most likely run across some `edge cases` like blank spaces and special characters `!`. Because these edge cases are not included in our original `alphabet` array from letters `'a'..'z'`, `Ruby` will treat these as `nil` and return an error as a result. So to make sure that the program will still work given these characters, we can simply create an `if/else` block that will check to see if the character passed in from the user's input is `nil`. If `true`, then we just have `Ruby` add these characters as they are into the new string we are creating, and do not worry about trying to encrypt them Otherwise, `Ruby` will continue to iterate over each character and encrypt those letters until it comes to the end of the user's input.

As a stylistic approach, we can incorporate the `.upcase` method which we would call on our new string so that it prints all characters passed into the new string in all caps and reads more like what one might expect for an encrypted message.

Outside of `class CaesarCipher`, we can ask for the user's input with a couple of prompts to the console, one for the message they would like encrypted, and the other for the number of positions they wish to use for an encryption key. We create our two variables for the user's input, and in both cases we assign each respective variable to `gets.chomp`. With the number of positions though, we will have to convert the user's input to an integer, so that assignment to the variable will be `gets.chomp.to_i`. From here, we instantiate our instance, for example, `cipher` and pass in the position argument that we get from our user's encryption key input. Finally, we invoke our method by calling encrypt on our `cipher` instance and passing in the user's string input as an argument to the `def encrypt` method. The results can then be printed to the console with the `puts` method and we should see a complete scramble of uppercase letters that are actually an encrypted message from the user!
